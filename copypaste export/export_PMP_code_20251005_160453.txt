--- Export du projet 'C:\Users\Jean\Desktop\PMP' | Généré le 10/05/2025 16:04:53 ---

====================================================================
--- Fichier: Appspecifications.md
====================================================================

NE PAS MODIFIER sauf demande explicite

Cahier des Charges Projet — Version Finale et Complète

Objectif : Poser tout ce qu’il faut décider/collecter avant la 1ʳᵉ ligne de code. Ce document sert de cahier des charges de référence.

1) Vision & Périmètre

Pitch (1–2 phrases) : …

Objectifs mesurables (OKR/metrics) : ex: MVP fonctionnel, <500 ms TTFB, mise en place de tests unitaires (Vitest) et end-to-end (Playwright) pour les parcours critiques.

Personas & cas d’usage clés :

Utilisateur → importe, trie, recadre et planifie ses publications.

Administrateur → supervise l'ensemble des comptes, accède aux données de n'importe quel utilisateur, monitore l'usage de la plateforme et peut intervenir pour de la maintenance ou de la restauration.

Périmètre MVP :

Inclus : Le workflow complet de la galerie à la publication pour un utilisateur, l'authentification, et le tableau de bord administrateur (visualisation et accès aux données).

Exclus : Pas de gestion de vidéos, pas de collaboration en temps réel, pas d'interface UI spécifiquement optimisée pour mobile (l'architecture doit cependant le permettre).

Contraintes (tech/légales/business) : RGPD, multi-utilisateur avec cloisonnement strict des données, hébergement auto-géré via Docker avec une architecture portable vers les plateformes cloud.

2) Structure de l’Interface (UI globale)
🧭 En-tête (Header)

Position : Toujours visible en haut de l’écran.

Contenu :

Gauche : Logo de l’application.

Centre : Barre d’onglets horizontale représentant les étapes du processus utilisateur.

Droite : Photo de profil, Icône engrenage ⚙️.

📑 Onglets principaux (pour l'Utilisateur)
Étape	Nom de l’onglet	Description courte
1	Galerie	Importation, affichage et sélection des images.
2	Tri	Classement, suppression ou réorganisation des images.
3	Recadrage	Recadrage automatique et manuel des photos.
4	Description	Ajout de titres, tags, légendes, métadonnées.
5	Calendrier	Planification des publications.
6	Publication	Validation et export.
👑 Interface Administrateur

Accessible via une route protégée (/admin), avec une interface distincte.

Tableau de bord de monitoring :

Santé du Système : Utilisation CPU/RAM, état de la file d'attente (jobs en attente/échoués).

Analyse Utilisateurs : Stockage total par utilisateur, nombre d'images, graphiques d'activité.

Gestion Utilisateurs : Liste des utilisateurs, possibilité de se "connecter en tant que" pour le support.

⚡ États de l'Interface & Feedback

Chargement : Des squelettes d'interface (skeletons) seront utilisés pour le chargement progressif des galeries.

États Vides : Une vue vide (ex: pas de galeries) affichera un message clair et une action principale (ex: bouton "Ajouter des photos" au centre).

Notifications : Utilisation de "toasts" non bloquants pour les confirmations. Une modale de confirmation est réservée aux actions destructrices (ex: suppression d'une galerie).

3) Stack Technique & Architecture Produit

Front-end : Next.js (App Router), React, Tailwind + shadcn/ui.

Données : Prisma + PostgreSQL.

State management : TanStack Query (requêtes) + Zustand (état global).

Déploiement & DevEx :

Docker Compose pour le développement. Le fichier docker-compose.yml doit permettre de lancer l'intégralité de l'environnement (App, DB, Worker, Redis) avec une seule commande.

Docker pour la production, avec une architecture portable.

Architecture Asynchrone :

Worker Dédié : Un service Node.js séparé pour les tâches longues (traitement d'images, exports ZIP).

File d'attente (Queue) : Redis + BullMQ pour communiquer entre l'application et le worker.

Tests Automatisés : Vitest (unitaire/intégration) et Playwright (end-to-end).

Observabilité : Logs structurés en JSON avec Pino.

🖼️ Spécifications — Onglet « Galerie »

Sidebar gauche redimensionnable : Liste des galeries par ordre alphabétique, avec bouton d'ajout et de suppression.

État de sélection : Cliquer une galerie devient la galerie sélectionnée (état global).

Vue centrale (grille) :

Affichage des photos en letterbox dans des carrés.

Performance : La grille doit utiliser une librairie de virtualisation (ex: TanStack Virtual) pour garantir des performances fluides même avec des milliers d'images.

Contrôles : Zoom, sélecteur de Tri (alphabétique, date...).

Bouton “Ajouter des photos” en haut à droite.

Comportement :

Première ouverture : galerie vierge avec bouton d'ajout au centre.

Si des galeries existent : ouvrir la dernière ajoutée.

À préciser :

[✅] Confirmation avant suppression d’une galerie (modale).

[✅] Persistance de la largeur de la sidebar.

[✅] Source du tri « récent/ancien » (date d'import).

✂️ Spécifications — Onglet « Recadrage »

Layout : Toggle Manuel/Auto, drawer pour les galeries, zone de recadrage centrale, filmstrip en dessous.

Mode « Recadrage manuel » :

Affiche l'image originale avec une boîte de recadrage au ratio cible (par défaut 4:5).

Boîte de recadrage : 8 poignées, drag, rotation de l'image sous la boîte.

Contrôles : "White bars" (letterbox), "Split" (génère deux variantes alignées).

Sauvegarde : Chaque action produit une nouvelle ImageVariant (non destructif), avec autosave à la navigation.

Mode « Recadrage automatique » :

Déclenchement : L'action dans l'UI envoie une requête à l'API pour lancer un job asynchrone côté serveur via smartcrop.js (ou équivalent).

Feedback : L'interface affiche une barre de progression mise à jour via polling de l'API.

Filmstrip : Navigation entre les images via clic ou flèches clavier.

🗄️ Modèle de données

Multi-utilisateur : Toutes les tables principales (Gallery, Image, Publication, etc.) doivent inclure une relation vers l'utilisateur (userId) pour assurer le cloisonnement.

Rôles : Le modèle User doit contenir un champ role (USER | ADMIN).

ImageVariant : Entité pour stocker chaque variante de sortie.

Champs : id, sourceImageId, userId, type (crop, white_bars...), URLs, dimensions.

PublicationImage : Référence un imageVariantId et une position.

🔌 API — Spécifications

Sécurité : Toutes les routes sont protégées et valident les droits de l'utilisateur sur la ressource demandée (vérification du userId).

Contrat pour les Tâches Asynchrones (Jobs) :

Lancement (POST /api/jobs) : L'API reçoit la tâche, la met en file d'attente et répond immédiatement avec un jobId.

Suivi (GET /api/jobs/:jobId) : Route que le front-end interroge (polling) pour obtenir le statut (QUEUED, RUNNING, COMPLETED, FAILED) et la progression.

🖱️ Drag & Drop — Spécification unifiée

Objectif : Réorganisation fluide des images dans les blocs de publication et les filmstrips.

Persistance : Chaque réorganisation met à jour le champ PublicationImage.position via un appel API (POST /api/publications/:id/reorder).

Feedback : Animation de déplacement + toast de confirmation.

🗓️ Calendrier & Export

Couleurs par galerie : Palette de couleurs assignée dynamiquement aux galeries pour une meilleure lisibilité.

Téléchargement :

Bouton pour télécharger un bloc ou une journée en ZIP.

Le ZIP est généré côté serveur (job asynchrone) et contient les variantes d'images finales (01.jpg, 02.jpg...) et un metadata.json.

🚀 Mises à Jour & Maintenance (Stratégie Zéro Downtime)

Base de Données : Les migrations de schéma sont gérées par prisma migrate deploy pour des mises à jour sans interruption.

Déploiement du Code : L'architecture doit permettre un déploiement "blue-green" (la nouvelle version démarre, le trafic bascule, l'ancienne s'arrête) pour garantir une absence de temps d'arrêt.

Feature Flags : Un système de "feature flags" permettra à un admin d'activer/désactiver des fonctionnalités depuis son interface pour des déploiements progressifs et sécurisés.

✅ Mini-checklist de clôture (avant dev)

Environnement de dev avec docker-compose (one-command startup) est fonctionnel.

Le schéma Prisma intègre multi-utilisateur (userId) et les rôles.

Le contrat d'API pour les jobs asynchrones est implémenté.

L'architecture pour l'interface Admin (monitoring système & utilisateur) est esquissée.

La stratégie de tests (Vitest/Playwright) est définie.

La virtualisation de la grille est confirmée comme un prérequis technique.

La stratégie de mise à jour (migrations, blue-green) est validée.

--- Fin de l'exportation ---
